.. default-domain:: chpl

.. module:: AdjListHyperGraph
   :synopsis: This is the first data structure for hypergraphs in chgl.  This data

AdjListHyperGraph
=================
**Usage**

.. code-block:: chapel

   use AdjListHyperGraph;

**Submodules**

.. toctree::
   :maxdepth: 1
   :glob:

   AdjListHyperGraph/*

This is the first data structure for hypergraphs in chgl.  This data
structure is an adjacency list, where vertices and edges are in the "outer"
distribution, and their adjacencies are in the "inner" distribution.
Currently, the assumption is that the inner distribution of adjacencies is
shared-memory, but it should be possible to easily change it to distributed.
If we choose to distributed adjacency lists (neighbors), we may choose a
threshold in the size of the adjacency list that causes the list of neighbors
to be distributed since we do not want to distribute small neighbor lists.

This version of the data structure started out in the SSCA2 benchmark and has
been modified for the label propagation benchmark (both of these benchmarks
are in the Chapel repository).  Borrowed from the chapel repository. Comes
with Cray copyright and Apache license (see the Chapel repo).


.. data:: config const AdjListHyperGraphDisableAggregation = false

   
   Disable aggregation. This will cause all calls to `addInclusionBuffered` to go to `addInclusion` and
   all calls to `flush` to do a NOP.
   

.. data:: config const AdjListHyperGraphDisablePrivatization = false

   
   This will forward all calls to the original instance rather than the privatized instance.
   

.. data:: config param AdjListHyperGraphIndexBits = 64

.. record:: AdjListHyperGraph

   
   Record-wrapper for the AdjListHyperGraphImpl. The record-wrapper follows from the optimization
   that Chapel's arrays, domains, and ranges use to eliminate communication that is inherent in
   in how Chapel represents pointers to potentially remote objects. Pointers in Chapel can be your
   normal 64-bit integer, or a widened 128-bit C struct, which holds both the 64-bit pointer
   as well as the locale id (32-bit integer) and a sublocale id (32-bit integer), the former used to
   describe the cluster node the memory is hosted on, and the latter describing the NUMA node the
   memory is allocated on. This is also the reason why you can declare a `atomic` class instance
   in Chapel.
   
   Since objects are hosted on a single node and do not migrate, a load and store to an object allocated
   in some other locale's address space will resolve to a GET and PUT respectively. Method invocation of
   a remote object is handled locally, but each load/store to the class fields are treated as remote PUT/GET,
   resulting in abysmal performance. To instruct that a method be performed on the locale that it is allocated
   on, care should be used that the body of the method is wrapped in an `on this` block. Note that it is not
   always appropriate to do this, as this creates a load imbalance and will result to degrading performance;
   as well, it has been found that with Cray's Aries Network Atomics, remote PUT/GET operations are significantly
   faster than remote execution. 
   
   The AdjListHyperGraph makes use of privatization, a process in which a local-copy of the object is created
   on each locale, documented as part of the DSI (Domain map Standard Interface). Privatization internally is
   implemented as a runtime table (C array), where the user can retrieve a privatized copy by the privatization
   id, the index into the table. Each copy will share the same privatization id so that it can be used across
   multiple locales; all locales will create a privatized copy, even the ones that the data structure is not
   intended to be distributed over. Calling `_newPrivatizedClass(this)` will create a privatized copy on each
   locale. Calling `chpl_getPrivatizedClass(this.type, pid)` where `pid` is the privatization id, will obtain
   the privatized instance for the current node to work on. Be aware that you must always access data through
   the privatized instance for performance sake, and that privatized instances, after creation, can be mutated
   independently of each other.
   
   Note also: arrays make use of a specific compiler-optimization for their record-wrappers called 'remote value
   forwarding' where the record is used by value in `forall` and `coforall` loops, rather than by reference.
   Since this is currently hard-coded for Chapel's arrays and domains, the user must manually make a copy of the
   record-wrapper to prevent it from being used by-reference, thereby negating the whole point of privatization.
   Hint: A reference to a remote object is treated as a wide pointer.
   


   .. attribute:: var instance

   .. attribute:: var pid = -1

   .. method:: proc _value

   .. method:: proc init(numVertices: integral, numEdges: integral)

   .. method:: proc init(numVertices: integral, numEdges: integral, mapping)

   .. method:: proc init(numVertices: integral, numEdges: integral, verticesMappings, edgesMappings)

   .. method:: proc init(propMap: ?vPropTypePropertyMap?ePropType, vertexMappings = new unmanaged DefaultDist(), edgeMappings = new unmanaged DefaultDist())

   .. method:: proc init(other: AdjListHyperGraph)

   .. method:: proc clone(other: this.type )

   .. method:: proc destroy()

.. function:: proc fromAdjacencyList(fileName: string, separator = ",", map: ?t = new unmanaged DefaultDist()) throws

.. record:: Lock

   .. attribute:: var contentionCnt: atomicint(64)

   .. attribute:: var _lock$: sync(bool)

   .. method:: proc acquire()

   .. method:: proc release()

.. function:: proc acquireLocks(ref a: Lock, ref b: Lock)

.. function:: proc releaseLocks(ref a: Lock, ref b: Lock)

.. class:: NodeData

   
   NodeData: stores the neighbor list of a node.
   
   This record should really be private, and its functionality should be
   exposed by public functions.
   
   TODO: Add this node's id so that it can be used for locking order.
   


   .. attribute:: type nodeIdType

   .. attribute:: type propertyType

   .. attribute:: var property: propertyType

   .. attribute:: var incidentDomain = {0..1}

   .. attribute:: var incident: [incidentDomain] nodeIdType

   .. attribute:: var lock: Lock

   .. attribute:: var isSorted: bool

   .. attribute:: var size: atomicint

   .. method:: proc init(type nodeIdType, property: ?propertyType)

   .. method:: proc init(type nodeIdType, type propertyType)

   .. method:: proc init(other: ?nodeIdTypeNodeData?propertyType)

   .. method:: proc equals(other: this.type , param acquireLock = true)

   .. method:: proc makeDistinct(param acquireLock = true)

   .. method:: proc canWalk(other: this.type , s = 1, param acquireLock = true)

   .. method:: proc neighborIntersection(other: this.type , param acquireLock = true)

   .. method:: proc sortIncidence(param acquireLock = false)

   .. method:: proc isIncident(n: nodeIdType, param acquireLock = true)

   .. method:: proc isIncident(other)

   .. method:: proc degree

   .. method:: proc cap

   .. method:: proc resize(sz = cap+1)

   .. method:: proc addIncidence(ns: nodeIdType, param acquireLock = true)

      
      This method is not parallel-safe with concurrent reads, but it is
      parallel-safe for concurrent writes.
      

   .. method:: proc this(idx: integral) ref

   .. itermethod:: iter these() ref

   .. itermethod:: iter these(param tag: iterKind) ref

   .. method:: proc readWriteThis(f)

.. record:: ArrayWrapper

   .. attribute:: var dom = {0..-1}

   .. attribute:: var arr: [dom] int

.. function:: proc ==(a: ArrayWrapper, b: ArrayWrapper)

.. function:: proc !=(a: ArrayWrapper, b: ArrayWrapper)

.. function:: proc chpl__defaultHash(r: ArrayWrapper): uint

.. record:: Vertex

.. record:: Edge

.. record:: Wrapper

   .. attribute:: type nodeType

   .. attribute:: type idType

   .. attribute:: var id: idType

   .. method:: proc type make(id)

      
      Based on Brad's suggestion:
      
      https://stackoverflow.com/a/49951164/594274
      
      The idea is that we can call a function on the type.  In the
      cases where type is instantiated, we will know `nodeType` and
      `idType`, and we can just refer to them in our make method.
      

   .. method:: proc type null()

   .. method:: proc readWriteThis(f)

.. function:: proc <(a: ?nodeTypeWrapper?idType, b: nodeTypeWrapperidType): bool

.. function:: proc ==(a: ?nodeTypeWrapper?idType, b: nodeTypeWrapperidType): bool

.. function:: proc !=(a: ?nodeTypeWrapper?idType, b: nodeTypeWrapperidType): bool

.. function:: proc >(a: ?nodeTypeWrapper?idType, b: nodeTypeWrapperidType): bool

.. function:: proc _cast(type t: ?nodeTypeWrapper?idType, id: integral)

.. function:: proc _cast(type t: ?nodeTypeWrapper?idType, id: nodeTypeWrapperidType)

.. function:: proc _cast(type t: ?nodeTypeWrapper?idType, id)

.. function:: proc id(wrapper)

.. enum:: enum InclusionType { Vertex, Edge }

.. class:: AdjListHyperGraphImpl

   
   Adjacency list hypergraph.
   
   The storage is an array of NodeDatas.  The edges array stores edges, and
   the vertices array stores vertices.  The storage is similar to a
   bidirectional bipartite graph.  Every edge has a set of vertices it
   contains, and every vertex has a set of edges it participates in.  In terms
   of matrix storage, we store CSR and CSC and the same time.  Storing
   strictly CSC or CSR would allow cutting the storage in half, but for now
   the assumption is that having the storage go both ways should allow
   optimizations of certain operations.
   


   .. attribute:: var _verticesDomain

   .. attribute:: var _edgesDomain

   .. attribute:: type _vPropType

   .. attribute:: type _ePropType

   .. attribute:: var pid = -1

   .. attribute:: type vIndexType = index(_verticesDomain)

   .. attribute:: type eIndexType = index(_edgesDomain)

   .. attribute:: type vDescType = VertexWrappervIndexType

   .. attribute:: type eDescType = EdgeWrappereIndexType

   .. attribute:: var _vertices: [_verticesDomain] unmanaged eDescTypeNodeData_vPropType

   .. attribute:: var _edges: [_edgesDomain] unmanaged vDescTypeNodeData_ePropType

   .. attribute:: var _destBuffer = new Aggregator((vIndexType, eIndexType, InclusionType))

   .. attribute:: var _propertyMap: _vPropTypePropertyMap_ePropType

   .. attribute:: var _privatizedVertices = _vertices._value

   .. attribute:: var _privatizedEdges = _edges._value

   .. attribute:: var _privatizedVerticesPID = _vertices.pid

   .. attribute:: var _privatizedEdgesPID = _edges.pid

   .. attribute:: var _masterHandle: unmanaged object

   .. attribute:: var _useAggregation: bool

   .. method:: proc init(numVertices = 0, numEdges = 0, vertexMappings, edgeMappings)

   .. method:: proc init(propMap: ?vPropTypePropertyMap?ePropType, vertexMappings = new unmanaged DefaultDist(), edgeMappings = vertexMappings)

   .. method:: proc clone(other: AdjListHyperGraphImpl)

   .. method:: proc init(other: AdjListHyperGraphImpl, pid: int(64))

   .. method:: proc verticesDomain

   .. method:: proc localVerticesDomain

   .. method:: proc edgesDomain

   .. method:: proc localEdgesDomain

   .. method:: proc vertices

   .. method:: proc edges

   .. method:: proc getVertex(idx: integral) ref

   .. method:: proc getVertex(desc: vDescType) ref

   .. method:: proc getVertex(other)

   .. method:: proc getEdge(idx: integral) ref

   .. method:: proc getEdge(desc: eDescType) ref

   .. method:: proc getEdge(other)

   .. method:: proc verticesDist

   .. method:: proc edgesDist

   .. method:: proc useAggregation

   .. method:: proc numEdges

   .. method:: proc numVertices

   .. method:: proc degree(vDesc: vDescType)

   .. method:: proc degree(eDesc: eDescType)

   .. method:: proc degree(other)

   .. itermethod:: iter walk(eDesc: eDescType, s = 1): eDescType

   .. itermethod:: iter walk(eDesc: eDescType, s = 1, param tag: iterKind): eDescType

   .. itermethod:: iter walk(vDesc: vDescType, s = 1): vDescType

   .. itermethod:: iter walk(vDesc: vDescType, s = 1, param tag: iterKind): vDescType

   .. itermethod:: iter getToplexes()

   .. itermethod:: iter getToplexes(param tag: iterKind)

   .. method:: proc getProperty(vDesc: vDescType): this._propertyMap.vertexPropertyType

   .. method:: proc getProperty(eDesc: eDescType): this._propertyMap.edgePropertyType

   .. method:: proc getProperty(other)

   .. method:: proc collapseVertices()

   .. method:: proc collapseEdges()

   .. method:: proc collapseSubsets()

   .. method:: proc collapse()

   .. method:: proc removeIsolatedComponents()

   .. itermethod:: iter getToplexes(param tag: iterKind): eDescType

   .. method:: proc isConnected(v1: vDescType, v2: vDescType, s)

   .. method:: proc isConnected(e1: eDescType, e2: eDescType, s)

   .. method:: proc getInclusions()

   .. itermethod:: iter getEdges(param tag: iterKind)

      
      Warning: If you call these inside of the `AdjListHyperGraphImpl`,
      there will not be any privatization, hence you _need_ to call
      getPrivatizedInstance; one easy way to do this is to do something
      like 'with (var _this = getPrivatizedInstance())' so that its only
      obtained once per task per locale.
      

   .. itermethod:: iter getEdges()

   .. itermethod:: iter getVertices(param tag: iterKind)

   .. itermethod:: iter getVertices()

   .. method:: proc emptyBuffer(buffer: unmanaged Buffer, loc: locale)

   .. method:: proc flushBuffers()

   .. method:: proc resizeEdges(size)

   .. method:: proc resizeVertices(size)

   .. method:: proc startAggregation()

   .. method:: proc stopAggregation()

   .. method:: proc addInclusionBuffered(vDesc: vDescType, eDesc: eDescType)

      
      Explicitly aggregate the vertex and element.
      

   .. method:: proc addInclusionBuffered(v: vIndexType, e: eIndexType)

   .. method:: proc addInclusionBuffered(vDesc: vDescType, e: eIndexType)

   .. method:: proc addInclusionBuffered(v: vIndexType, eDesc: eDescType)

   .. method:: proc addInclusionBuffered(v, e)

   .. method:: proc addInclusion(vDesc: vDescType, eDesc: eDescType)

      
      Adds 'e' as a neighbor of 'v' and 'v' as a neighbor of 'e'.
      If aggregation is enabled via 'startAggregation', this will 
      forward to the aggregated version, 'addInclusionBuffered'.
      

   .. method:: proc addInclusion(v: vIndexType, e: eIndexType)

   .. method:: proc addInclusion(vDesc: vDescType, e: eIndexType)

   .. method:: proc addInclusion(v: vIndexType, eDesc: eDescType)

   .. method:: proc addInclusion(v, e)

   .. method:: proc hasInclusion(v: vIndexType, e: eIndexType)

   .. method:: proc hasInclusion(vDesc: vDescType, e: eIndexType)

   .. method:: proc hasInclusion(v: vIndexType, eDesc: eDescType)

   .. method:: proc hasInclusion(vDesc: vDescType, eDesc: eDescType)

   .. method:: proc hasInclusion(v, e)

   .. method:: proc removeDuplicates()

   .. method:: proc toEdge(id: integral)

   .. method:: proc toEdge(desc: eDescType)

   .. method:: proc toEdge(other) param

   .. method:: proc toVertex(id: integral)

   .. method:: proc toVertex(desc: vDescType)

   .. method:: proc toVertex(other)

   .. method:: proc getVertexDegrees()

      
      Returns vertex degree sequence as array.
      

   .. method:: proc getEdgeDegrees()

      
      Returns hyperedge cardinality sequence as array.
      

   .. method:: proc getLocale(v: vDescType): locale

      
      Obtain the locale that the given vertex is allocated on
      

   .. method:: proc getLocale(e: eDescType): locale

      
      Obtain the locale that the given edge is allocated on
      

   .. itermethod:: iter intersection(e1: eDescType, e2: eDescType)

   .. itermethod:: iter intersection(e1: eDescType, e2: eDescType, param tag: iterKind)

   .. itermethod:: iter intersection(v1: vDescType, v2: vDescType)

   .. itermethod:: iter intersection(v1: vDescType, v2: vDescType, param tag: iterKind)

   .. method:: proc _snapshot(v: vDescType)

   .. method:: proc _snapshot(e: eDescType)

   .. itermethod:: iter incidence(e: eDescType)

   .. itermethod:: iter incidence(e: eDescType, param tag: iterKind) ref

   .. itermethod:: iter incidence(v: vDescType) ref

   .. itermethod:: iter incidence(v: vDescType, param tag: iterKind) ref

   .. itermethod:: iter incidence(arg)

   .. itermethod:: iter incidence(arg, param tag: iterKind)

   .. itermethod:: iter these(): (vDescType, eDescType)

   .. itermethod:: iter these(param tag: iterKind): (vDescType, eDescType)

   .. method:: proc this(v: vDescType)

   .. method:: proc this(e: eDescType)

.. function:: proc +=(graph: AdjListHyperGraph, other)

.. function:: proc +=(graph: unmanaged AdjListHyperGraphImpl, chpl__tuple_arg_temp: (graph.vDescType, graph.eDescType))

.. function:: proc +=(graph: unmanaged AdjListHyperGraphImpl, chpl__tuple_arg_temp: (graph.eDescType, graph.vDescType))

.. function:: proc +=(graph: unmanaged AdjListHyperGraphImpl, other)

