.. default-domain:: chpl

.. module:: WorkQueue

WorkQueue
=========
**Usage**

.. code-block:: chapel

   use WorkQueue;

.. data:: config const workQueueMinTightSpinCount = 8

.. data:: config const workQueueMaxTightSpinCount = 1024

.. data:: config const workQueueMinVelocityForFlush = 1

.. data:: config const workQueueVerbose = false

.. data:: param WorkQueueUnlimitedAggregation = -1

.. data:: param WorkQueueNoAggregation = 0

.. iterfunction:: iter doWorkLoop(wq: WorkQueue(?workType), td: TerminationDetector): workType

.. iterfunction:: iter doWorkLoop(wq: WorkQueue(?workType), td: TerminationDetector, param tag: iterKind): workType

.. function:: proc <=>(ref wq1: WorkQueue, ref wq2: WorkQueue)

.. function:: proc UninitializedWorkQueue(type workType)

.. record:: WorkQueue

   .. attribute:: type workType

   .. attribute:: var instance: unmanaged WorkQueueImpl(workType)

   .. attribute:: var pid = -1

   .. method:: proc init(type workType, numAggregatedWork: int = WorkQueueNoAggregation)

   .. method:: proc isInitialized()

   .. method:: proc _value

.. class:: WorkQueueImpl

   .. attribute:: type workType

   .. attribute:: var pid = -1

   .. attribute:: var queue = new unmanaged Bag(workType)

   .. attribute:: var destBuffer = UninitializedAggregator(workType)

   .. attribute:: var dynamicDestBuffer = UninitializedDynamicAggregator(workType)

   .. attribute:: var asyncTasks: TerminationDetector

   .. attribute:: var shutdownSignal: atomicbool

   .. method:: proc init(type workType, numAggregatedWork: int)

   .. method:: proc init(other, pid)

   .. method:: proc destroy()

   .. method:: proc globalSize

   .. method:: proc size

   .. method:: proc workPending

   .. method:: proc dsiPrivatize(pid)

   .. method:: proc dsiGetPrivatizeData()

   .. method:: proc getPrivatizedInstance()

   .. method:: proc shutdown()

   .. method:: proc isShutdown()

   .. method:: proc addWork(work: workType, loc: locale)

   .. method:: proc addWork(work: workType, locid = here.id)

   .. method:: proc getWork(): (bool, workType)

   .. method:: proc isEmpty()

   .. method:: proc flushLocal()

   .. method:: proc flush()

.. data:: config const workQueueInitialBlockSize = 1024

.. data:: config const workQueueMaxBlockSize = 1024*1024

.. class:: Bag

   .. attribute:: type eltType

   .. attribute:: var startIdxEnq: chpl__processorAtomicType(uint)

      
      Helps evenly distribute and balance placement of elements in a best-effort
      round-robin approach. In the case where we have parallel enqueues or dequeues,
      they are less likely overlap with each other. Furthermore, it increases our
      chance to find our 'ideal' segment.
      

   .. attribute:: var startIdxDeq: chpl__processorAtomicType(uint)

   .. attribute:: var maxParallelSegmentSpace = {0..#here.maxTaskPar}

   .. attribute:: var segments: [maxParallelSegmentSpace] BagSegment(eltType)

   .. method:: proc nextStartIdxEnq

   .. method:: proc nextStartIdxDeq

   .. method:: proc init(type eltType)

   .. method:: proc deinit()

   .. method:: proc size

   .. method:: proc add(elt: eltType): bool

   .. method:: proc remove(): (bool, eltType)

.. function:: proc main()

