.. default-domain:: chpl

.. module:: WorkQueue

WorkQueue
=========
**Usage**

.. code-block:: chapel

   use WorkQueue;

.. data:: config const workQueueMinTightSpinCount = 8

.. data:: config const workQueueMaxTightSpinCount = 1024

.. data:: config const workQueueMinVelocityForFlush = 1

.. data:: config const workQueueMinDifferenceForSteal = 1024*1024

.. data:: config const workQueueVerbose = false

.. data:: param WorkQueueUnlimitedAggregation = -1

.. data:: param WorkQueueNoAggregation = 0

.. iterfunction:: iter doWorkLoop(wq: WorkQueue(?workType), td: TerminationDetector, doWorkStealing = false): workType

.. iterfunction:: iter doWorkLoop(wq: WorkQueue(?workType), td: TerminationDetector, doWorkStealing = false, param tag: iterKind): workType

.. function:: proc <=>(ref wq1: WorkQueue, ref wq2: WorkQueue)

.. record:: DuplicateCoalescer

   .. attribute:: type t

   .. attribute:: var dupValue: t

   .. method:: proc init(type t, dupValue: t)

   .. method:: proc this(A: [?D] ?t)

.. record:: NopCoalescer

   .. attribute:: type t

   .. method:: proc init(type t)

   .. method:: proc this(arr: [?D] t)

.. function:: proc UninitializedWorkQueue(type workType, coalesceFn: ?t = NopCoalescer(workType))

.. record:: WorkQueue

   .. attribute:: type workType

   .. attribute:: type colaesceFnType

   .. attribute:: var instance: unmanaged workTypeWorkQueueImplcolaesceFnType

   .. attribute:: var pid = -1

   .. method:: proc init(type workType, numAggregatedWork: int = WorkQueueNoAggregation, coalesceFn: ?t = new NopCoalescer(workType))

   .. method:: proc isInitialized()

   .. method:: proc _value

.. class:: WorkQueueImpl

   .. attribute:: type workType

   .. attribute:: var pid = -1

   .. attribute:: var queue = new unmanaged Bag(workType)

   .. attribute:: var destBuffer = UninitializedAggregator(workType)

   .. attribute:: var dynamicDestBuffer = UninitializedDynamicAggregator(workType)

   .. attribute:: var asyncTasks: TerminationDetector

   .. attribute:: var shutdownSignal: atomicbool

   .. attribute:: var coalesceFn

   .. method:: proc init(type workType, numAggregatedWork: int, coalesceFn: ? = new NopCoalescer(workType))

   .. method:: proc init(other, pid)

   .. method:: proc destroy()

   .. method:: proc globalSize

   .. method:: proc size

   .. method:: proc workPending

   .. method:: proc dsiPrivatize(pid)

   .. method:: proc dsiGetPrivatizeData()

   .. method:: proc getPrivatizedInstance()

   .. method:: proc shutdown()

   .. method:: proc isShutdown()

   .. method:: proc addWork(work: workType, loc: locale)

   .. method:: proc addWork(work: workType, locid = here.id)

   .. method:: proc getWork(): (bool, workType)

   .. method:: proc getWorkBulk(n: integral)

   .. method:: proc isEmpty()

   .. method:: proc flushLocal()

   .. method:: proc flush()

.. data:: config const workQueueInitialBlockSize = 1024

.. data:: config const workQueueMaxBlockSize = 1024*1024

.. class:: Bag

   .. attribute:: type eltType

   .. attribute:: var startIdxEnq: chpl__processorAtomicType(uint)

      
      Helps evenly distribute and balance placement of elements in a best-effort
      round-robin approach. In the case where we have parallel enqueues or dequeues,
      they are less likely overlap with each other. Furthermore, it increases our
      chance to find our 'ideal' segment.
      

   .. attribute:: var startIdxDeq: chpl__processorAtomicType(uint)

   .. attribute:: var maxParallelSegmentSpace = {0..#here.maxTaskPar}

   .. attribute:: var segments: [maxParallelSegmentSpace] BagSegment(eltType)

   .. method:: proc nextStartIdxEnq

   .. method:: proc nextStartIdxDeq

   .. method:: proc init(type eltType)

   .. method:: proc deinit()

   .. method:: proc size

   .. method:: proc addBulk(elts: [?D] eltType)

   .. method:: proc add(elt: eltType): bool

   .. method:: proc removeBulk(n: integral)

      
      Obtain work in bulk; returns an array with a size of at most 'n'.
      

   .. method:: proc remove(): (bool, eltType)

.. function:: proc main()

