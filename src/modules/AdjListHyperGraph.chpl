/* Start at a graph library module.
   This version started out in the SSCA2 benchmark
   and has been modified for the label propagation benchmark.
   Borrowed from the chapel repository. Comes with Cray copyright and Apache license (see the Chapel repo).
 */

// TODO: Intents on arguments?
// TODO: Graph creation routines.

module AdjListHyperGraph {
  use IO;

  //
  // NodeData: stores the neighbor list of a node.
  //
  /* private */
  record NodeData {
    type nodeIdType;

    var ndom = {0..-1};
    var neighborList: [ndom] nodeIdType;
    // This is purely a lock, and the boolean type is just an arbitrary choice.  TBD: Is there a better lock?
    var lock$: sync bool = true;

    proc numNeighbors() return ndom.numIndices;

    // Initializers are necessary:
    // https://stackoverflow.com/questions/49682634/domain-resizing-on-an-array-of-records-hangs
    // Since they are rather boring, it could be better if at some point they were generated by the compiler.

    // Generic initializer
    proc init(type nodeIdType) {
      this.nodeIdType = nodeIdType;
    }

    // This copy initializer is not intended to be parallel-safe and may be incorrect if `other` is being modified.
    // If we do not have this initializer, copy constructors cause problems with the sync variable where it gets emptied by copy constructors.  If it was not for the sync variable, we probably do not need these initializers specified explicitly.
    proc init(other: AdjListHyperGraph) {
      other.lock$; // Lock the other.  This makes the copy construction parallel-safe with respect to other and may be a bit of an overkill.
      this.nodeIdType = other.nodeIdType;
      this.ndom = other.ndom;
      this.neighborList = other.neighborList;
      other.lock$ = true; // release the lock
      // this.lock$ will be assigned by the default initializer
    }

    // This method is not parallel-safe with concurrent reads, but it is parallel-safe for concurrent writes.
    proc addNodes(vals) {
      lock$; // acquire lock
      neighborList.push_back(vals);
      lock$ = true; // release the lock
    }

    proc readWriteThis(f) {
      f <~> new ioLiteral("{ ndom = ") 
	<~> ndom 
	<~> new ioLiteral(", neighborlist = ") 
	<~> neighborList 
	<~> new ioLiteral(", lock$ = ") 
	<~> lock$.readXX() 
	<~> new ioLiteral("(isFull: ") 
	<~> lock$.isFull
	<~> new ioLiteral(") }");
    }
  } // record VertexData
  
  // Assignment is parallel-safe with respect to adding nodes and other write operations on NodeData, but attempt at circular assignment may read to deadlock (e.g., ``
  proc =(ref lhs: NodeData, ref rhs: NodeData) {
    lhs.lock$; // lock lhs
    rhs.lock$; // lock rhs
    lhs.ndom = rhs.ndom;
    lhs.neighborList = rhs.neighborList;
    lhs.lock$ = true; // release lhs
    rhs.lock$ = true; // release rhs
  }

  record Vertex {}
  record Edge   {}

  record Wrapper {
    type nodeType;
    type idType;
    var id: idType;
  }

  proc id ( wrapper ) {
    return wrapper.id;
  }
  
  /* store a hypergraph 
   */
  class AdjListHyperGraph {
    var vertices_dom; // generic type - domain of vertices
    var edges_dom; // generic type - domain of edges
    
    type vIndexType = index(vertices_dom);
    type eIndexType = index(edges_dom);
    type vType = Wrapper(Vertex, vIndexType);
    type eType = Wrapper(Edge, eIndexType);
    
    var vertices: [vertices_dom] NodeData(vType);
    var edges: [edges_dom] NodeData(eType);

    // Initialize a graph with initial domains
    proc init(vertices_dom, edges_dom) {
      this.vertices_dom = vertices_dom;
      this.edges_dom = edges_dom;
    }

    // Default initializer creates an empty graph
    proc init() {
      this.vertices_dom = {0..-1};
      this.edges_dom = {0..-1};
    }
    
    proc Neighbors ( e : eType ) {
      return edges(e.id).neighborList;
    }

    proc Neighbors ( v : vType ) {
      return vertices(v.id).neighborList;
    }

    proc Neighbors ( e : eIndexType ) {
      return edges(e).neighborList;
    }

    // Resize the edges array
    // This is not parallel safe AFAIK.
    // No checks are performed, and the number of edges can be increased or decreased
    proc resize_edges(size) {
      edges_dom = {0..(size-1)};
    }

    // Resize the vertices array
    // This is not parallel safe AFAIK.
    // No checks are performed, and the number of vertices can be increased or decreased
    proc resize_vertices(size) {
      vertices_dom = {0..(size-1)};
    }
      
    /* proc readWriteThis(f) { */
    /*   f <~> new ioLiteral("Vertices domain: ") <~> vertices_dom <~> new ioNewline() */
    /* 	<~> new ioLiteral("Vertices: ") <~> vertices <~> new ioNewline() */
    /*     <~> new ioLiteral("Edges domain: ") <~> edges_dom <~> new ioNewline() */
    /* 	<~> new ioLiteral("Edges: ") <~> edges <~> new ioNewline(); */
    /* } */
  } // class Graph
  
  /* /\* iterate over all neighbor IDs */
  /*  *\/ */
  /* private iter Neighbors( nodes, node : index (nodes.domain) ) { */
  /*   for nlElm in nodes(node).neighborList do */
  /*     yield nlElm(1); // todo -- use nid */
  /* } */
  
  /* /\* iterate over all neighbor IDs */
  /*  *\/ */
  /* iter private Neighbors( nodes, node : index (nodes), param tag: iterKind) */
  /*   where tag == iterKind.leader { */
  /*   for block in nodes(v).neighborList._value.these(tag) do */
  /*     yield block; */
  /* } */
  
  /* /\* iterate over all neighbor IDs */
  /*  *\/ */
  /* iter private Neighbors( nodes, node : index (nodes), param tag: iterKind, followThis) */
  /*   where tag == iterKind.follower { */
  /*   for nlElm in nodes(v).neighborList._value.these(tag, followThis) do */
  /*     yield nElm(1); */
  /* } */

  /* /\* return the number of neighbors */
  /*  *\/ */
  /* proc n_Neighbors (nodes, node : index (nodes) )  */
  /*   {return Row (v).numNeighbors();} */
  

  /*   /\* how to use Graph: e.g. */
  /*      const vertex_domain =  */
  /*      if DISTRIBUTION_TYPE == "BLOCK" then */
  /*      {1..N_VERTICES} dmapped Block ( {1..N_VERTICES} ) */
  /*      else */
  /*      {1..N_VERTICES} ; */
	
  /*      writeln("allocating Associative_Graph"); */
  /*      var G = new Graph (vertex_domain); */
  /*   *\/ */

  /*   /\* Helps to construct a graph from row, column, value */
  /*      format.  */
  /*   *\/ */
  /* proc buildUndirectedGraph(triples, param weighted:bool, vertices) where */
  /*   isRecordType(triples.eltType) */
  /*   { */

  /*     // sync version, one-pass, but leaves 0s in graph */
  /*     /\* */
  /* 	var r: triples.eltType; */
  /* 	var G = new Graph(nodeIdType = r.to.type, */
  /* 	edgeWeightType = r.weight.type, */
  /* 	vertices = vertices); */
  /* 	var firstAvailNeighbor$: [vertices] sync int = G.initialFirstAvail; */
  /* 	forall trip in triples { */
  /*       var u = trip.from; */
  /*       var v = trip.to; */
  /*       var w = trip.weight; */
  /*       // Both the vertex and firstAvail must be passed by reference. */
  /*       // TODO: possibly compute how many neighbors the vertex has, first. */
  /*       // Then allocate that big of a neighbor list right away. */
  /*       // That way there will be no need for a sync, just an atomic. */
  /*       G.Row[u].addEdgeOnVertex(v, w, firstAvailNeighbor$[u]); */
  /*       G.Row[v].addEdgeOnVertex(u, w, firstAvailNeighbor$[v]); */
  /* 	}*\/ */

  /*     // atomic version, tidier */
  /*     var r: triples.eltType; */
  /*     var G = new Graph(nodeIdType = r.to.type, */
  /*                       edgeWeightType = r.weight.type, */
  /*                       vertices = vertices, */
  /*                       initialLastAvail=0); */
  /*     var next$: [vertices] atomic int; */

  /*     forall x in next$ { */
  /*       next$.write(G.initialFirstAvail); */
  /*     } */

  /*     // Pass 1: count. */
  /*     forall trip in triples { */
  /*       var u = trip.from; */
  /*       var v = trip.to; */
  /*       var w = trip.weight; */
  /*       // edge from u to v will be represented in both u and v's edge */
  /*       // lists */
  /*       next$[u].add(1, memory_order_relaxed); */
  /*       next$[v].add(1, memory_order_relaxed); */
  /*     } */
  /*     // resize the edge lists */
  /*     forall v in vertices { */
  /*       var min = G.initialFirstAvail; */
  /*       var max = next$[v].read(memory_order_relaxed) - 1;  */
  /*       G.Row[v].ndom = {min..max}; */
  /*     } */
  /*     // reset all of the counters. */
  /*     forall x in next$ { */
  /*       next$.write(G.initialFirstAvail, memory_order_relaxed); */
  /*     } */
  /*     // Pass 2: populate. */
  /*     forall trip in triples { */
  /*       var u = trip.from; */
  /*       var v = trip.to; */
  /*       var w = trip.weight; */
  /*       // edge from u to v will be represented in both u and v's edge */
  /*       // lists */
  /*       var uslot = next$[u].fetchAdd(1, memory_order_relaxed); */
  /*       var vslot = next$[v].fetchAdd(1, memory_order_relaxed); */
  /*       G.Row[u].neighborList[uslot] = (v,); */
  /*       G.Row[v].neighborList[vslot] = (u,); */
  /*     } */

  /*     return G; */
  /*   } */
}

